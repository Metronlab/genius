package tmpl

import (
	"bytes"
	"errors"
	"fmt"
	data2 "github.com/Metronlab/genius/internal/data"
	"go/format"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

const Ext = ".tmpl"

func Tmpl(dataPath string, values ValuesList, goImportsEnable bool, args []string) error {
	var err error
	entries := data{
		Values: values,
	}

	if dataPath == "" {
		return errors.New("data option is required")
	}

	if goImportsEnable {
		if _, err := exec.LookPath("goimports"); err != nil {
			return fmt.Errorf("failed to find goimports: %w", err)
		}
		formatter = formatSource
	} else {
		formatter = format.Source
	}

	if len(args) == 0 {
		return errors.New("no tmpl files specified")
	}

	specs := make([]pathSpec, len(args))
	for i, p := range args {
		if specs[i], err = parsePathSpec(p); err != nil {
			return err
		}
	}

	entries.Data, err = data2.ReadFileData(dataPath)
	if err != nil {
		return fmt.Errorf("impossible to read input data file: %w", err)
	}

	return process(entries, specs)
}

type pathSpec struct {
	in, out string
}

func (p *pathSpec) String() string { return p.in + " â†’ " + p.out }
func (p *pathSpec) IsGoFile() bool { return filepath.Ext(p.out) == ".go" }

func parsePathSpec(path string) (pathSpec, error) {
	p := strings.IndexByte(path, '=')
	if p == -1 {
		if filepath.Ext(path) != Ext {
			return pathSpec{}, fmt.Errorf("template file '%s' must have '%s' extension", path, Ext)
		}
		return pathSpec{path, path[:len(path)-len(Ext)]}, nil
	}

	return pathSpec{path[:p], path[p+1:]}, nil
}

type data struct {
	Data   interface{}
	Values ValuesList
}

type ValuesList map[string]string

func (l ValuesList) String() string {
	res := make([]string, 0, len(l))
	for k, v := range l {
		res = append(res, fmt.Sprintf("%s=%s", k, v))
	}
	return strings.Join(res, ", ")
}

func (l ValuesList) Set(v string) error {
	nv := strings.Split(v, "=")
	if len(nv) != 2 {
		return fmt.Errorf("expected NAME=VALUE, got %s", v)
	}
	l[nv[0]] = nv[1]
	return nil
}

func writeResult(spec pathSpec, generated []byte) error {
	stat, err := os.Stat(spec.in)
	if err != nil {
		return err
	}
	return ioutil.WriteFile(spec.out, generated, stat.Mode())
}

var funcs = template.FuncMap{
	"stringsLower": strings.ToLower,
	"stringsUpper": strings.ToUpper,
	"stringsTitle": strings.Title,
}

func process(data interface{}, specs []pathSpec) error {
	for _, spec := range specs {
		var (
			t   *template.Template
			err error
		)

		tmplContent, err := ioutil.ReadFile(spec.in)
		if err != nil {
			return fmt.Errorf("impossible to read input template data: %w", err)
		}

		t, err = template.New("gen").Funcs(funcs).Parse(string(tmplContent))
		if err != nil {
			return fmt.Errorf("error processing template '%s': %w", spec.in, err)
		}

		var buf bytes.Buffer
		if spec.IsGoFile() {
			// preamble
			if _, err := fmt.Fprintf(&buf, "// Code generated by %s. DO NOT EDIT.\n", spec.in); err != nil {
				return fmt.Errorf("impossible to write header: %w", err)
			}
			if _, err := fmt.Fprintln(&buf); err != nil {
				return fmt.Errorf("impossible to write header: %w", err)
			}
		}
		err = t.Execute(&buf, data)
		if err != nil {
			return fmt.Errorf("error executing template '%s': %w", spec.in, err)
		}

		generated := buf.Bytes()
		if spec.IsGoFile() {
			generated, err = formatter(generated)
			if err != nil {
				return fmt.Errorf("error formatting template '%s': %w", spec.in, err)
			}
		}

		if err := writeResult(spec, generated); err != nil {
			return fmt.Errorf("impossible to write resulting file: %w", err)
		}
	}
	return nil
}

var (
	formatter func([]byte) ([]byte, error)
)

func formatSource(in []byte) ([]byte, error) {
	r := bytes.NewReader(in)
	cmd := exec.Command("goimports")
	cmd.Stdin = r
	out, err := cmd.Output()
	if err != nil {
		if ee, ok := err.(*exec.ExitError); ok {
			return nil, fmt.Errorf("error running goimports: %s", string(ee.Stderr))
		}
		return nil, fmt.Errorf("error running goimports: %s", string(out))
	}

	return out, nil
}
